mod decode;
mod execute;
mod event;
mod message;

use crate::{CALL_STACK_END, CALL_STACK_START, Op, Parser, Register::FP, Registers};
use crate::Event::Send;
use crate::mem::{Memory, StackManager};

pub use self::decode::Decode;
pub use self::execute::Execute;
pub use self::event::Event;
pub use self::message::{Action, Message};

#[derive(Debug)]
pub struct Machine {
    /// Addressable identifier of the machine.
    pub id: Option<u16>,

    /// Memory buffer of the machine.
    pub mem: Memory,

    /// Registers of the machine.
    pub reg: Registers,

    /// Events generated by the machine.
    pub events: Vec<Event>,

    /// Mailbox contains messages sent to this machine.
    pub mailbox: Vec<Message>,

    /// Is the machine in debug mode?
    pub is_debug: bool,

    /// How many messages does the machine expect to receive?
    pub expected_receives: u16,
}

impl Machine {
    /// Creates a new machine.
    pub fn new() -> Machine {
        Machine {
            id: None,

            mem: Memory::new(),
            reg: Registers::new(),

            events: vec![],
            mailbox: vec![],

            is_debug: false,
            expected_receives: 0,
        }
    }

    /// Returns a stack manager for the current machine.
    pub fn stack(&mut self) -> StackManager {
        let mut stack = StackManager::new(&mut self.mem, &mut self.reg);
        stack.is_debug = self.is_debug;
        stack
    }

    pub fn call_stack(&mut self) -> StackManager {
        let mut stack = self.stack();
        stack.sp = FP;
        stack.min = CALL_STACK_START;
        stack.max = CALL_STACK_END;
        stack
    }

    /// Reset the memory and registers to avoid faulty state.
    pub fn reset(&mut self) {
        self.reg.reset();
        self.mem.reset();
    }

    /// Push a message to a recipient's mailbox.
    pub fn send_message(&mut self, to: u16, action: Action) {
        // If the machine has no address, it cannot send messages.
        let Some(id) = self.id else { return; };

        // Add the message to the mailbox.
        let message = Message { from: id, to, action };
        self.events.push(Send { message: message.clone() });
    }

    /// Processes incoming messages
    /// TODO: do we use the `receive` instruction for every kind of message?
    pub fn process_message(&mut self) {
        while self.expected_receives > 0 {
            self.expected_receives -= 1;

            let Some(message) = self.mailbox.pop() else { break; };

            match message.action {
                // If the message is a data message, push the data onto the stack.
                Action::Data { body } => {
                    for v in body.iter() {
                        self.stack().push(*v).expect("push error");
                    }
                }
            }
        }
    }
}

impl From<Vec<Op>> for Machine {
    fn from(code: Vec<Op>) -> Self {
        let mut m = Machine::new();
        m.mem.load_code(code);
        m
    }
}

impl From<&str> for Machine {
    fn from(source: &str) -> Self {
        let p: Parser = source.into();
        let mut m: Self = p.ops.into();
        m.mem.load_symbols(p.symbols);
        m
    }
}

